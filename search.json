[{"title":"expected ~~~ 1 bean ~~~ candidate","url":"/2020/07/26/error/expected-1-bean-candidate/","content":"\nexpected at least 1 bean which qualifies as autowire candidate 의 해결했던 경험\n\n이 메시지를 첨봤는데 어노테이션으로 스프링 구성된 특징상 직접 실행해야 알려준다.\n\n내가 발생했을때는 정상적으로 주입이 되지 않았을때 생기는 오류였는데 오류메시지를 보면 어떠한 파일에 오류가 발생했는지 뜬다.\n\n그 파일에 들어가서 @Service, @Repository 등의 어노테이션이 정상적으로 써졌는지 확인하면 된다.\n\n필자의 경우는 @Service가 빠져있어서 등록하고 정상적으로 수정되었다.","tags":["error"],"categories":["error"]},{"title":"부적합한 열 유형 1111","url":"/2020/07/18/error/1111/","content":"\n부적합한 열 유형 1111 오류에 관하여 작성\n\n타입이 잘못들어갔을때 발생하는데 개인적으로 오라클에서만 경험했었다. 물론 타 dbms에서 발생하지 않으리란 보장은 없다.\n\n해결방법은 열 유형을 정확히 맞춰주면 된다. 숫자열은 숫자만 문자열은 문자만 \n\n특히 not null인 열에 null이 들어간경우도 이 오류가 뜨니 오류메시지를 확인 후 dbms를 다룰 수 있는 툴에 쿼리랑 파라미터를 넣고 돌려보면 뭐가 문제인지 알 수 있다.","tags":["error"],"categories":["error"]},{"title":"네티 5 - 바이트 버퍼","url":"/2020/04/12/netty/day5/","content":"\n<h2>바이트</h2>\n\n말그대로 1바이트를 저장하는 변수입니다.\n\n원래는 1바이트는 -128에서 127의 범위를 가지지만 통신 관련 작업할때는 부호가 없는 0~255까지의 범위에서 씁니다.\n\n저 같은 경우는 통신할 때 써봤고 16진수로 변환하여 통신을 했습니다.\n\n그 외에는 쓰일곳이 저 같은 초보에게는 많을 것 같지는 않습니다. 나중이라면 많이 쓸 수 있겠지만요.\n\n<h2>java.nio.ByteBuffer</h2>\n\n자바에서 바이트 데이터를 저장하고 읽을 수 있도록 바이트버퍼를 제공합니다.\n\n실제 버퍼를 구현하기 위해 배열을 이용하고 있으며 배열의 인덱스에 접근하지 않아도 쉽게 작업할 수 있도록 여러 메소드를 제공합니다.\n\n책에 따르면 버퍼의 상태를 관리하는 속성 세 가지를 제공하는데 다음과 같다고 합니다.\n\ncapacity : 버퍼에 저장할 수 있는 최대 크기로 한번 정하면 변경이 불가능하며 생성자의 인수로 입력한 값이다.\nposition : 읽기 또는 쓰기가 작업중인 위치를 나타내며 처음 생성시 0으로 초기화되고 position <= limit <= capacity의 범위를 가진다.\nlimit : 읽고 쓸 수 있는 버퍼 공간의 최대치를 나타내며 capacity 보다 크게 설정할 수 없다.\n저 세개의 값으로 버퍼에서 읽고 쓰는데 도움을 주며 각각 속성의 사용법은 아래의 사진을 보고 참조하시면 좋을 것 같습니다.\n\n<img src=\"https://user-images.githubusercontent.com/20100284/51082041-f8715200-1741-11e9-844f-0b51e7b6f109.png\"/> \n\n간단히 살펴보면 position과 limit로 어디까지 작업할지 선택하며 capacity로 오버플로우가 발생하지 않도록 체크하는 느낌입니다.\n\n<h2>버퍼 만들기</h2>\n\n자바에서 보통 객체 생성을 할 때는 new 생성자를 이용하지만 자바의 바이트 버퍼는 데이터 형에 따른 추상클래스 팩토리 메소도를 통해 생성합니다.\n\n생성하는 메소드는 세 가지가 존재하며 다음과 같습니다.\n\n1. allocate : JVM의 힙 영역에 바이트 버퍼를 생성합니다.\n2. allocateDirect : JVM이 아닌 운영체제의 커널 영역에 바이트 버퍼를 생성합니다.\n3. wrap : 입력된 바이트 배열을 사용하여 버퍼를 생성합니다. 말그대로 일반 바이트 배열을 버퍼로 wrap해주는 용도라 보시면 될 것 같습니다.\n보통 다이렉트 버퍼가 힙에 생성된 버퍼에 비해 생성 시간은 길지만 빠른 성능을 제공합니다.\n\n기본적인 생성 방법은 다음과 같습니다.\n{% codeblock %}\npublic class javaBufSample {\n\n    public void createTest() {\n        ByteBuffer heapBuffer = ByteBuffer.allocate(3);\n        ByteBuffer directBuffer = ByteBuffer.allocateDirect(3);\n        byte[] testArray = {0x01, 0x02, 0x03};\n        ByteBuffer wrapBuffer = ByteBuffer.wrap(testArray);\n\n        System.out.println(heapBuffer.isDirect());      //false\n        System.out.println(directBuffer.isDirect());    //true\n        System.out.println(heapBuffer.isDirect());      //false\n    }\n}\n{% endcodeblock %}\n실행해 보시면 다이렉트 버퍼만 true고 나머지는 false로 되어있는 것을 볼 수 있습니다.\n즉, wrap메소드의 처리결과로 봐서 직접적으로 명시하지 않는 이상 JVM의 영역을 기본적으로 사용한다는 것을 확인할 수 있습니다. 사실 당연한거죠..\n\n보통 문자열이나 숫자등의 처리를 위해 byte형으로 변경할 수 있도록 메소드를 제공하고 있습니다.\n그리고 선언한 버퍼의 크기보다 많으면 <code>java.nio.BufferOverflowException</code>이 발생합니다.\n\n-flip 메소드-\n\n하나의 바이트 버퍼가 쓰고 있다고 가정해봅시다. 쓰기 모드에서 버퍼에 데이터를 기록하면 position은 데이터의 가장 마지막을, limit는 버퍼의 가장 마지막을 가리키고 있을 것입니다.\n이 버퍼에서 지금까지 작성한 데이터를 읽고 싶다면 예제야 0~position까지 읽으면 되겠지만 실제에서는 어떻게 되있을지 모르며 0부터 읽을 수 있을지 없을지도 모릅니다.\n그래서 자바에서는 읽기에서 쓰기모드를 변환시켜주는 filp 메소드를 제공합니다.\n이 메소드를 사용하면 버퍼에 존재한 데이터를 바탕으로 속성들의 위치를 변경시켜줍니다.\n\n즉, 위의 그림에서 왼쪽에서 오른쪽으로 변경해 데이터를 안전하게 읽으려면 filp 메소드가 필요한 것이죠.\n이러한 특성때문에 다중 스레드환경이나 읽기/쓰기를 분리해야 하는 등 불편한 사항이 많다고 합니다.\n\n<h2>io.netty.buffer.ByteBuf</h2>\n\nNetty 바이트 버퍼는 자바 바이트 버퍼보다 더 빠른 성능을 제공하며 버퍼 풀 등 여러가지 기능을 많이 가지고 있습니다. 이 바이트 버퍼가 가진 특징은 다음과 같습니다.\n\n1. 별도의 읽기/쓰기 인덱스 존재\n2. filp 메소드 없이 읽기/쓰기 가능\n3. 가변 바이트 버퍼\n4. 바이트 버퍼 풀\n5. 복합 버퍼\n6. 자바의 바이트 버퍼와 상호 변환 가능\n이러한 바이트 버퍼를 따로 사용할 수 있도록 버퍼만 따로 클래스로 제공하기도 하니 필요하시면 가져다가 쓰시면 되겠습니다.\n그리고 자바의 경우 intBuffer 등의 자료형마다 따로 버퍼클래스를 제공하지만 Netty 에서는 readInt/writeInt등의 자료형별로 메소드를 따로 제공하여 사용합니다.\n\n사용해보기\n\n먼저 Netty 바이트 버퍼를 생성할 때 풀링 여부 / 다이렉트 여부 두 가지를 선택해야 합니다.\n그래서 이 기능에 따라 생성 가능한 버퍼 종류는 네가지입니다.\n\n1. PooledHeapByteBuf\n2. PooledDirectByteBuf\n3. UnPooledHeapByteBuf\n4. UnPooledDirectByteBuf\n자바에서 추상 클래스의 팩토리 메소드를 사용해 생성했듯이 Netty도 클래스의 생성자가 아닌 메소드를 사용하여 생성합니다.\n한 번 만들어 보겠습니다.\n\n{% codeblock %}\npublic class NettyBufSmaple {\n    public void createTest(){\n        ByteBuf PooledHeapByteBuf = PooledByteBufAllocator.DEFAULT.heapBuffer();\n        ByteBuf PooledDirectByteBuf = PooledByteBufAllocator.DEFAULT.directBuffer();\n        ByteBuf UnPooledHeapByteBuf = Unpooled.buffer();\n        ByteBuf UnPooledDirectByteBuf = Unpooled.directBuffer();\n    }\n}\n{% endcodeblock %}\n변수명을 보시면 어떻게 만들 수 있는지 보실 수 있습니다. 크기의 경우 메소드에 인자로 넣어주시면 크기가 지정 가능합니다.\n\n그 외 특징으로는 capacity로 쉽게 크기 변경이 가능하며 readIndex/writeIndex의 분리로 인해 쉽게 읽고 쓰는 작업이 가능합니다.\n\n<h2>바이트 버퍼 풀링</h2>\n\nNetty의 가장 중요한 특징은 바이트 버퍼 풀링입니다.\n객체 생성 등의 비용을 최대한으로 줄이기 위해 풀링 방법을 사용하며 다이렉트/힙 버퍼에 대해 모두 사용할 수 있습니다.\n이러한 풀링으로 인해 GC에 부담을 적게 주며 메모리를 다른 곳에 더 사용할 수 있도록 합니다.\n\nReferenceCountUtil 클래스에 정의된 retain/release 메소드를 사용하여 풀링의 크기를 관리할 수 있습니다.\n\nC언어와 같이 변수에 부호가 없는 경우 Netty는 한단계 더 큰 데이터형에 저장합니다.\n예를 들면, getUnsignedInt 메소드를 호출 할 경우 int->long으로 업그레이드 해서 반환하는 식입니다.\n\n자바 -> Netty 간 바이트버퍼 상호 변환을 위해 nioByteBuffer 메소드를 제공합니다.\nNetty -> 자바에서는 wrappedBuffer 메소드를 사용하시면 됩니다.","tags":["Netty"],"categories":["Netty"]},{"title":"네티 4 - 이벤트 핸들러","url":"/2020/04/12/netty/day4/","content":"네티 알아보기 4일차 - 이벤트 핸들러\n\n<h2>이벤트 루프</h2>\n\n네티에서 빼놓을 수 없는 이벤트에 대해서 알아보고자 합니다.\n\n통상적인 이벤트 기반 어플리케이션이 이벤트를 처리하는 방법은 크게 두 가지라고 합니다.\n\n1. 이벤트 리스너와 이벤트 처리 스레드에 기반한 방법\n2. 이벤트 큐에 이벤트를 등록하고 이벤트 루프가 큐에 접근하여 사용하는 방법\n\n맨 위의 방식은 대부분의 UI처리 프레임워크가 사용하는 방법이라고 합니다. 로직을 리스너에 등록하고 처리 스레드가 등록된 로직을 수행하는 방식이죠.\n\n생각나는 예를 들면\n{% codeblock %}\nJS : document.getElementById(\"myBtn\").addEventListener(\"click\", displayDate);\n{% endcodeblock %}\n두번쨰 방식인 이벤트 루프+큐의 방식은 객체에서 이벤트가 발생하면 이벤트 큐에 입력되고 이벤트 루프 스레드가 체크해서 이벤트를 가져와 처리하는 방식입니다.\n\n계속해서 체크하며 돌기 때문에 Loop인것일까요?\n\n여기서 스레드가 단일과 다중으로 나뉘고 이벤트의 결과를 돌려주는 방식에 따라 콜백 패턴과 퓨처 패턴으로 나뉩니다.\nNetty는 둘 다 지원한다고 하니 잠시 후 알아보겠습니다.\n\n<h2>단일/다중 스레드 이벤트 루프</h2>\n\n단일 스레드 루프는 이벤트를 처리하는 스레드가 하나인 상태를 말합니다.\n그래서 하나의 입력된 스레드가 이벤트 큐에 입력된 이벤트를 처리하므로 큐에 입력된 이벤트를 순차적으로 실행이 가능한 장점을 가지고 있지요.\n단점은 당연히 기본 멀티코어인 요즘 시대에 코어를 1개밖에 못써먹는 치명적인 단점이 있습니다.\n\n다중 스레드 루프는 이벤트를 처리하는 스레드가 여러개인 상태를 말합니다.\n단점은 이벤트 루프의 갯수가 한정적이므로 접근하려는 경합이 일어나며 여러 스레드가 실행하므로 실행순서와 발생순서가 일치하지 않습니다.\n하지만 장점은 남는 자원을 아낌없이 다 쓸 수 있다는 점이지요.\n\n영상하나를 올리고자 합니다. 해당 영상은 CPU vs GPU 영상 입니다만 CPU를 단일스레드, GPU를 멀티스레드라고 생각해보면 그림을 그린다는 목적을 똑같이 가졌을 때 멀티스레드로 인한 효율을 간접적으로 볼 수 있습니다.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/-P28LKWTzrI\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\nnvidia youtube에서 퍼왔습니다.\n\n하지만 다중 스레드 루프도 만능은 아닙니다. 스레드 경합과 컨텍스트 스위칭(스레드가 가진 스택 정보를 레지스터로 복사하는 작업)에 의한 비용이 늘어나서 코어의 활용으로 인한 성능향상보다 성능을 깎아먹게 되는 현상이 있으니 늘 적당한 갯수를 탄력적으로 모니터링하며 유지해야 하겠습니다.\n\n<h2>네티의 이벤트 루프</h2>\n\nNetty가 다중 스레드 루프를 사용했다면 너도 나도 가져가려는 이벤트 스레드로 인해 전송하다가 채널이 닫히는 등 엄청난 혼란이 일어났겠지만 Netty의 경우 다음과 같은 특징으로 인하여 다중 스레드 루프를 사용함에도 단점을 극복했다고 합니다.\n\n네티의 이벤트는 채널에서 발생 -> 이벤트 루프 객체는 큐를 가지고 있다 -> 네티의 채널은 하나의 이벤트 루프에 등록된다.\n즉, 1채널당 1개의 이벤트 루프에만 등록되기 때문에 한곳에서만 처리가 가능하다는 것이지요.\n그리고 루프 객체당 큐를 가지고 있기 때문에 큐를 공유하지 않아 다른 객체에서 해당 큐의 접근이 불가능하여 이벤트를 빼앗기는 일이 없다고 하겠습니다.\n\n조금 비유하면 컨퍼런스를 갔는데 여러 홀에서 동시에 발표를 한다 가정하면 우리의 몸이 만화속 닌자마냥 분신술이 불가능하기 때문에 하나의 발표밖에 못듣게 되죠.\n그래서 여러 발표(이벤트)를 함에도 홀(이벤트 큐)이 공유되지 않아 하나의 발표밖에 못듣는거죠.(이벤트 처리)\n\n<h2>네티의 비동기 I/O 처리</h2>\n\n앞서 살펴보았던 이벤트 처리에 비해 유용하게 쓸 수 있는 퓨처패턴을 사용해 보겠다고 합니다.(책에서)\n퓨처패턴은 당장 완료되지는 않지만 언젠가는 완료될 것으로 생각하고 미리 짜 놓으면 퓨처 객체에서 메소드의 처리 결과에 따라 진행하는 패턴입니다.\n\n간단한 코드로 표현하면 다음과 같은 것입니다.(실제로 실행은 안되니 의사코드로써 봐주시기 바랍니다.)\n\n{% codeblock %}\npublic class NettyFuture {\n    public static void main(String[] args) {\n        Work work = new Work();\n        Future<Work> nettyFuture = new Future<Work>() {\n            if (future.isDone) {\n                //일이 끝났다 다음 해야할 일을...\n            } else {\n                //끝나지 않았으니 빨리 빨리 정신으로 갈구자\n            }\n        }\n    }\n}\n{% endcodeblock %}\n실제로 여러분이 처음 작성한 코드에서는 퓨처패턴이 사용중이었습니다.\n{% codeblock %}\nChannelFuture f =bootstrap.bind(8888).sync();\nf.channel().closeFuture().sync();\n{% endcodeblock %}\n위의 채널퓨처 객체를 사용하고 있었죠. sync() 메소드가 bind의 결과가 올 때 까지 블로킹하고 bind의 처리가 완료되면 같이 sync메소드도 진행됩니다.\n위의 채널이 닫힐 경우 sync로 같이 닫아주는 형식으로 진행되고 있죠.\n\n즉 퓨처패턴은 일단 프로그래머는 로직을 짜면 추후에 미래의 결과에 따라 진행하는 방식입니다.\n\n퓨처패턴의 진행결과를 가져와서 처리해야 하는데 while로 계속해서 가져오는 방식도 있으나 복잡성 증가라던지 조금 그래서… 이벤트 방식의 리스너에 담아서 사용도 가능합니다.\n\n<code>ChannelFuture.addListener(ChannelFutureListener.CLOSE)</code> <-- 이런식으로 말이죠\n다음은 해당리스너 인터페이스를 구현하면 될 것이고요.\n\n일단 ChannelFutureListener 인터페이스만 살펴보면 해당 인터페이스를 통해서 제공하는 것은 다음과 같습니다.\n\n{% codeblock %}\nChannelFutureListener.CLOSE\nChannelFutureListener.CLOSE_ON_FAILURE\nChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE\n{% endcodeblock %}\n그 외에 여러가지 이벤트 리스너를 사용해서 비동기의 제어도 가능합니다.\n\n<code>ChannelFuture.addListener API</code>\n\n보시는것과 같이 꼭 하나의 리스너만 받고 있지는 않으니 여러가지로 응용하시면 되겠습니다.\n\n결론\n\n네티의 이벤트 루프 스레드는 단일과 다중 스레드에서 이벤트 수행 순서의 차이가 없는 것이 장점이며 루프 스레드의 갯수를 쉽게 조정할 수 있으니 편하신대로 개발하시면 되겠습니다.\n더 적은 고민으로 좋은 품질의 제품을 만들 수 있도록 해주었으니 잘 써먹어야겠죠.","tags":["Netty"],"categories":["Netty"]},{"title":"네티 3 - 채널 파이프라인 + 코덱","url":"/2020/03/25/netty/day3/","content":"\n<h2>주요 용어들</h2>\n\n채널 파이프라인 - 채널에서 발생한 이벤트가 이동하는 통로\n이벤트 핸들러 - 채널 파이프라인을 따라 이동한 이벤트를 처리하는 클래스\n코덱 - 이벤트 핸들러를 상속받아서 구현한 것\n네티의 이벤트 실행\n\n보통의 연결된 소켓에서 데이터를 받는다면 다음과 같은 로직으로 처리할 것입니다.\n\n1. 소켓에 데이터가 있는지 확인\n2. 데이터가 있으면 읽는 메서드를 호출 후 데이터 처리\n3. 데이터가 올 때 까지 기달리다가 오면 2번으로 돌아감\n4. 네트워크가 종료되면 관련된 부분 처리\n\nNetty에서는 다음과 같이 처리합니다.\n\n1. 데이터가 들어오면 Netty의 이벤트 루프가 채널 파이프라인에 등록된 첫 번째 이벤트 핸들러를 가져온다.\n2. 이벤트 핸들러에 데이터 수신 후 작동할 이벤트가 있는지 확인\n3. 가져온 이벤트 핸들러에 관련 메소드가 없으면 이벤트가 처리되거나 핸들러를 다 가져올떄까지 계속 반복\n4. 네트워크가 종료되면 관련된 부분 처리\n\n즉, 데이터를 입출력 후 처리하는 부분은 이벤트로 관리하고 있으니 이벤트 처리만 해주면 Netty를 쉽게 쓸 수 있습니다.\n\n<h2>채널 파이프라인</h2>\n\n<p><img src=\"https://user-images.githubusercontent.com/20100284/50535726-5887c600-0b90-11e9-9a1a-b81707c78ce5.png\" alt=\"netty.io API의 설명\"></p>\n\n저렇게 채널에서 이벤트를 받으면 파이프라인으로 들어가서 이벤트 핸들러에 의해 맞는 이벤트를 처리하게 됩니다.\n하나의 채널 파이프라인에 여러 이벤트 핸들러를 등록할 수 있습니다.\n\n다시 에코서버안의 내용을 가져와서 보겠습니다.\n\n{% codeblock %}\nbootstrap.group(loopGroup, workerGroup)\n         .channel(NioServerSocketChannel.class)\n         .childHandler(new ChannelInitializer<SocketChannel>() {\n           protected void initChannel(SocketChannel socketChannel) throws Exception {\n             ChannelPipeline pipeline = socketChannel.pipeline();\n             pipeline.addLast(new EchoServerHandler());\n           }\n         });\n{% endcodeblock %}\n\n해당 코드를 보면 ChannelPipeline pipeline = socketChannel.pipeline()에서 파라미터로 받은 채널안의 파이프라인을 가져오고 다음 pipeline.addLast(new EchoServerHandler()) 메소드로 파이프라인의 마지막에 핸들러를 등록하는 것을 볼 수 있습니다.\n\n그리고 Netty는 소켓채널에 파이프라인을 등록하고 핸들러의 설정을 등록하기 위해서 세 단계 프로세스를 거칩니다.\n\n1. 클라이언트 연결에 대응하는 채널 객체를 생성하고 빈 채널 파이프라인 객체를 생성하여 소켓 채널에 할당합니다.\n2. 채널에 등록된 ChannelInitializer 인터페이스의 구현체를 가져와서 initChannel 메소드를 호출합니다.\n3. 1에서 등록된 파이프라인 객체를 가져온 후 파이프라인에 입력된 이벤트 핸들러 객체를 등록합니다.\n\n위의 세 단계가 완료 되면 채널이 등록됐다는 이벤트와 함께 데이터 송수신을 위한 이벤트 처리가 시작된다.\n\n<h2>이벤트 핸들러</h2>\n\nNetty는 비동기 처리를 위해 두가지를 제공합니다. 하나는 퓨처패턴이며 하나는 이벤트 핸들러입니다.\n책에서는 이벤트 핸들러에 대해 자세히 알아보겠습니다.\n\n대부분의 이벤트는 한 번만 수행하지만 다시 이벤트를 발생시켜 다른 등록된 핸들러에서 추가로 이벤트 처리를 시킬 수 있습니다.\n\n채널 인바운드 이벤트 - 인바운드 이벤트는 소켓 채널에서 발생한 이벤트 중 상대방이 어떤 동작을 취했을 때 발생합니다.\n클라이언트가 서버에 접속한 상태에서 서버에게 데이터를 보낼 경우 Netty의 소켓 채널은 데이터를 받았다고 채널 파이프라인에게 데이터 수신 이벤트를 보내고 채널 파이프라인은 등록한 인바운드 이벤트 핸들러를 호출합니다.\n\nChannelInboundHandler인터페이스를 가지고 인바운드 이벤트를 처리할 수 있습니다.\n안의 메소드는 다음과 같습니다.\n<p><img src=\"https://user-images.githubusercontent.com/20100284/50545348-05774700-0c54-11e9-8014-9de540244325.png\" alt=\"Inbound\"></p>\n\n이벤트 호출 순서는 다음과 같습니다.\n\n1. 이벤트 루프에 채널 등록(channelRegistered)\n2. 채널 활성화(channelActive)\n3. 데이터 수신(channelRead)\n4. 데이터 수신 완료(channelReadComplete)\n5. 채널 비활성화(channelInactive)\n6. 이벤트 루프에서 채널 제거(channelUnregistered)\n\n아마 대부분 메인로직은 데이터 수신~수신완료에 쓰일것이라 보입니다.\n\n이벤트를 간단히 정리해보겠습니다.\n\n1. channelRegistered의 이벤트 발생 시점은 서버와 클라이언트 모두 처음 소켓 채널이 생성할 때 발생하며, 서버의 경우 클라이언트 소켓 채널이 서버 소켓 채널에 등록될 때 다시 발생합니다.\n2. channelActive의 이벤트는 서버 또는 클라이언트가 연결한 직후 한 번 수행할 작업을 처리하기에 적합합니다.(예를 들면 Hello Client 라던가…)\n3. channelRead와 channelReadComplete 이벤트는 데이터의 수신시 발생하지만 Read는 채널에 데이터가 있을 때 발생하고 Complete는 데이터를 다 읽었을 때 발생합니다.\n4. channelInactive가 발생하면 Read가 불가능합니다.\n5. channelUnregistered가 발생하면 등록했던 소켓에 대한 이벤트 처리가 불가능합니다.\n\n채널 아웃바운드 이벤트 - 대부분 클라이언트 객체에서 처리할 것으로 보이는 아웃바운드입니다. 요청을 보내거나 데이터 전송, 소켓 닫기 등의 이벤트를 가지고 있습니다.\n<p><img src=\"https://user-images.githubusercontent.com/20100284/50545453-6ce2c600-0c57-11e9-8942-ee94220bf243.png\" alt=\"Outbound\"></p>\n\n이벤트를 간단히 정리해보면..\n\n1. bind 이벤트는 서버 소켓 채널에 클라이언트가 연결을 대기하는 IP와 포트가 설정되었을 때 발생합니다. 파라미터 중 SocketAddress로 서버에서 사용하는 IP/포트 정보를 확인 가능합니다.\n2. connect 이벤트는 서버에 연결되었을 때 발생합니다.\n3. disconnect 이벤트는 연결이 끊어졌을 때 발생합니다.\n4. close 이벤트는 소켓 채널의 연결이 닫혔을 때 발생합니다.\n5. write 이벤트는 소켓 채널에 데이터가 기록되면 발생합니다.\n6. flush 이벤트는 소켓 채널에 대한 flush 메소드가 호출되면 발생한다고 합니다.\n\n<h2>ChannelHandlerContext</h2>\n\n대부분의 이벤트가 ChannelHandlerContext를 파라미터로 제공하는 것을 볼 수 있습니다. 이 녀석의 경우 채널 파이프라인이나 다른 핸들러의 상호작용을 도와주는 인터페이스입니다.\n\n즉, writeAndFlush등의 메서드로 채널에 데이터를 기록하며 close 메소드로 연결종료나 자신이 속한 파이프라인의 동적 수정, 다음 Handler에 통지하는 등 다양한 기능을 수행합니다.\n\n<h2>코덱</h2>\n\n우리가 동영상 플레이어를 설치 시 말하는 그 코덱과 의미가 같습니다. 즉, 전송을 보내는/받은 파일을 특정 루틴에 의해 압축,변환 시키고 해제를 시키는 라이브러리 같은 개념으로 생각하면 되겠죠.\nNetty 에서는 코덱을 통해 데이터-패킷으로 상호 변환을 합니다. 그리고 Netty의 코덱은 템플릿 메소드 패턴을 사용했다고 합니다.(실행순서만 위에서 설정하고 실제 구현은 하위에서)\n\n사용자가 직접 만들 수 있지만 대부분의 프로토콜은 Netty에서 기본제공하므로 가져다가 쓰시는 것을 추천합니다.\n기본 예제는 io.netty.example 패키지에 포함되어있다고 합니다.","tags":["Netty"],"categories":["Netty(복구중)"]},{"title":"네티 2 - 프로토콜","url":"/2020/03/25/netty/day2/","content":"\n<h2>간단한 용어설명</h2>\n아무래도 통신관련 프레임워크기 때문에 통신 프로토콜을 모를 수도 없어서 간단하게 알아보도록 하겠습니다.\n\nTCP - TCP의 경우 연결을 확인하고 메시지를 전송하는 것을 보장하는 특성을 가지고 있습니다.메시지를 받을때마다 받았다는 신호를 보내 서로 전송되었고 받았는지 확인하죠.\n\nUDP - UDP는 메시지는 전송하지만 받았는지 전혀 확인하지 않기 때문에 누락, 분실, 메시지 순서를 보장하지 않는 등의 특징을 가지고 있습니다. 그럼에도 왜 쓰냐하면 체크하는 과정이 없기 때문에 TCP에 비해 상대적으로 오버헤드가 적고 속도가 빠른 장점이 있습니다.\n\nSCTP - IBM에서 좋은 정보를 제공하기에 가져왔습니다.\n\n스트림 전송 제어 프로토콜(SCTP)은 TCP와 유사한 연결 지향 프로토콜이지만 UDP와 유사한 메시지 지향 데이터 전송을 제공합니다. 일반적으로 SCTP는 안정적이면서도 메시지 지향적인 데이터 전송을 필요로 하는 VoIP(Voice over IP)와 같은 특정 애플리케이션에 대해 더 많은 유연성을 제공합니다. 이런 애플리케이션 범주에 대해 SCTP는 대부분 TCP나 UDP보다 더 적합합니다.\n\t•\tTCP는 신뢰 가능하며 엄격한 전송 순서의 데이터 전달을 제공합니다. 신뢰성이 필요로 하지만 순서화되지 않았거나 부분적으로만 순서화된 데이터 전달을 허용하는 애플리케이션의 경우, TCP는 HOL(head-of-line) 블로킹으로 인해 불필요한 지연을 초래할 수 있습니다. 단일 연결 내에 여러 스트림 개념을 사용하는 SCTP는 데이터를 다른 스트림으로부터 논리적으로 분리하는 동시에 하나의 스트림 내에서 엄격한 순서로 전달할 수 있습니다.\n\t•\tSCTP는 바이트 지향인 TCP와는 달리 메시지 지향입니다. TCP의 바이트 지향 특성으로 인해 애플리케이션은 메시지 경계를 유지하려면 고유한 레코드 표시를 추가해야 합니다.\n\t•\tSCTP는 멀티-홈 기능을 사용하여 어느 정도의 결함 허용치를 제공합니다. 호스트는 동일하거나 다른 네트워크에서 둘 이상의 네트워크 인터페이스가 접속된 경우 멀티-홈으로 간주됩니다. 두 개의 멀티-홈 호스트 사이에 SCTP 연관을 설정할 수 있습니다. 이 경우 두 엔드포인트의 모든 IP 주소가 연관 시작 시에 교환됩니다. 이를 통해 각 엔드포인트는 인터페이스 중 하나가 어떤 이유에서이건 작동 중지된 경우 대체 인터페이스를 통해 피어에 연결 가능한 한 남은 연결 기간 동안 이러한 주소를 사용할 수 있습니다.\n\t•\tSCTP는 TCP 및 UDP는 제공하지 않는 추가 보안 기능을 제공합니다. SCTP에서 연결 설정 시 자원 할당은 쿠키 교환 메커니즘을 사용하여 클라이언트의 ID를 검증하기 전까지 지연되어 서비스 거부 공격 가능성을 줄입니다.\n\n프로토콜간 차이점\n<p><img src=\"https://user-images.githubusercontent.com/20100284/50411940-77f8b900-0847-11e9-89af-4f0dc106a21b.png\" alt=\"차이점(어디서 가져온지 기억이 잘..)\"></p>\n￼\n<h2>부트스트랩이란?</h2>\n\n동명의 웹 프론트엔드 프레임워크가 아니라 Netty에서 가장 처음 수행되는 부분으로써 동작과 설정을 지정하여 가장 기본이 되는 부분이라 합니다. API Doc의 Bootstrap 클래스에서는 다음과 같이 얘기하고 있습니다 : 부트스트랩은 채널을 쉽게 사용할 수 있도록 해주는 것\n\n논리적 구조는 다음과 같습니다.\n\t•\t소켓 모드 및 I/O종류\n\t•\t이벤트 루프\n\t•\t채널 파이프라인 설정\n\t•\t소켓 주소 및 포트 등의 옵션 설정\n\n빌더 패턴을 사용하여 선택적인 옵션을 파악하기 쉽도록 추가할 수 있습니다.\n\n가장 처음에 작성했던 에코 서버 코드를 가져와서 조금 수정 후 확인해봅시다.\n\n{% codeblock %}\nEventLoopGroup loopGroup = new NioEventLoopGroup(1);\nEventLoopGroup workerGroup = new NioEventLoopGroup();\n\nServerBootstrap bootstrap = new ServerBootstrap();\nbootstrap.group(loopGroup, workerGroup)\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<SocketChannel>() {\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        ChannelPipeline pipeline = socketChannel.pipeline();\n                        pipeline.addLast(new EchoServerHandler());\n                    }\n                });\n\nChannelFuture f =bootstrap.bind(8888).sync();\nf.channel().closeFuture().sync();\n{% endcodeblock %}\n\n먼저 new NioEventLoopGroup()를 보면 생성자의 인수가 없는데 이럴 경우 사용할 스레드 수를 하드웨어의 스레드 수로 한다고 합니다. \n스레드 수는 하드웨어가 가지고 있는 CPU 코어 수의 2배를 사용한다 합니다. 4C 8T의 경우 하드웨어(CPU)에서 지원하는 8T의 두 배인 16개죠. \nloopGroup 변수는 사용할 스레드 수를 1개로 지정하였습니다. ServerBootstrap.group() 메소드는 NioEventLoopGroup을 인수로 받는데 첫번째는 연결에 사용할 스레드이고 두 번째 인수는 연결된 소켓에 대한 I/O처리를 담당합니다. \n\n위 코드에서는 연결의 경우 한번만 하고 끝나니 하나만 사용했고, I/O의 경우 어떻게 몇개가 들어올지 모르니 여러개의 스레드를 사용했다고 생각했습니다.\nchannel() 메소드는 API명세에 따르면 Channel 인터페이스를 구현한 객체나 채널팩토리를 사용할 수 있고 이 예제에서는 NioServerSocketChannel 클래스를 설정했기 때문에 Nio모드를 사용합니다.\nchildHandler 메소드는 API에 채널에서 요청이 왔을 때 제공할 ChannelHandler를 설정합니다.\n연결 방법을 바꾸고 싶으면 <code>.channel()</code> 부분에서 제공하는 클래스를 변경하면 입출력 모드를 쉽게 바꿀 수 있도록 Netty에서는 제공하고 있습니다. \nNetty에서 지원하는 클래스는 다음과 같습니다.(안보이면 우클릭 - 새탭에서 윈도우 열기)\n<p><img src=\"https://user-images.githubusercontent.com/20100284/50411468-8ba22080-0843-11e9-920e-54fe248d67a7.png\" alt=\"지원클래스 with Netty\"></p>￼\n\n이 중 Epoll은 *nix에서 동작한다고 합니다.\n\n부트스트랩 내 간단한 API 소개\nchannelFactory - 소켓 입출력 모드 설정\nchannel 메소드와 동일한 기능을 수행합니다.\nhandler - 이벤트 핸들러 설정\n소켓 채널에서 발생한 이벤트를 수신하여 처리합니다.\nchildHandler - 소켓 채널의 데이터 가공 핸들러 설정\n소켓 채널로 송수신 되는 데이터를 가공하는 핸들러입니다. ChannelHandler 인터페이스를 구현한 클래스를 인수로 입력 가능합니다.\noption - 소켓의 옵션을 설정합니다.\n소켓의 옵션이란 소켓의 동작 방식을 지정하는 것을 말합니다. 소켓 옵션은 어플리케이션의 값을 바꾸는 것이 아니라 커널에서 사용되는 값을 변경한다는 의미입니다.\nchildOption - 소켓의 옵션을 설정합니다.\noption 메소드는 서버의 옵션을, childOption 메소드는 클라이언트의 옵션을 설정합니다.\ngroup - 이벤트 루프 설정\n소켓 채널의 이벤트 처리를 위한 루프 객체를 생성합니다. 클라이언트는 단 하나의 이벤트 루프만 설정할 수 있습니다.\nchannel - 입출력모드 설정\n서버 - 클라이언트의 입출력 채널을 설정합니다. 서버와 클라이언트는 설정할 수 있는 입출력 모드가 상이합니다.\n\n결론\n부트스트랩으로 서버와 클라이언트에서 각자 연결하고 처리할 수 있는 방법을 쉽게 제공합니다. 여러가지 준비해 놓았으니 상황에 맞춰 가장 최적의 연결방법을 찾아서 해야 겠지요…","tags":["Netty"],"categories":["Netty(복구중)"]},{"title":"네티 1 - 기본 환경설정","url":"/2020/03/23/netty/day1/","content":"\n그동안 사놓고 안읽어봤던 자바 네트워크 소녀 Netty를 읽고 정리하면서 쓰는 글입니다.github blog + hexo로 만들어보는 첫번쨰 블로그이기도 하죠.\n\n네티란? Netty는 유지 보수 가능한 높은 성능 프로토콜 서버 &amp; 클라이언트를 빠르게 개발할 수 있는 비동기적인 이벤트 기반 네트워크 어플리케이션 프레임워크라고 합니다.\n<h2 id=\"시작해보기\">시작해보기</h2>\n1탄으로 Java 1.8 + maven 환경에서 작업해 보겠습니다. (추후에 생각나면 스프링도…) 라이브러리를 다운받아서 직접 lib 폴더에 넣으셔도 되지만 저는 그냥 maven으로 하겠습니다.\n\n가장 먼저 프로젝트를 만들고 pom.xml에 netty 레포지토리 태그를 집어넣습니다.\n\n개발환경은 5.0 alpha가 있지만 4.1 final버전으로 하겠습니다.\n\npom.xml에 다음과 같이 넣어주세요.\n\n그리고 maven install을 하셔서 lib에 netty.jar가 정상적으로 들어있는지 확인해주세요.\n\nintellij IDEA를 예로 들어서 정상적으로 라이브러리가 들어왔는지 확인 하려면 External Libraries에 들어있는지 확인하시면 되겠습니다.\n\n<img src=\"https://user-images.githubusercontent.com/20100284/50393342-fd716000-0798-11e9-9b1d-3aa65d041566.png\" alt=\"라이브러리 확인\">\n\n그럼 이제 Netty 프레임워크로 책내용을 따라서 만들어보겠습니다.\n\n<h2 id=\"에코서버-만들기\">에코서버 만들기</h2>\n\n서버를 만들어 봅시다.\n\n{% codeblock %}\npublic class EchoServer {\n    public void echo() throws InterruptedException {\n        EventLoopGroup loopGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {            \n                ServerBootstrap bootstrap = new ServerBootstrap();            \n                bootstrap.group(loopGroup, workerGroup).channel(NioServerSocketChannel.class)\n                         .childHandler(new ChannelInitializer<SocketChannel>() {                        \n                            protected void initChannel(SocketChannel socketChannel) throws Exception {                                       ChannelPipeline pipeline = socketChannel.pipeline();                            \n                                pipeline.addLast(new EchoServerHandler());                        \n                            }});            \n                ChannelFuture f =bootstrap.bind(8888).sync();           \n                f.channel().closeFuture().sync();       \n            } Catch(Exception ex) {\n                ex.printStackTrace();\n            }finally {\n                loopGroup.shutdownGracefully();            \n                workerGroup.shutdownGracefully();\n            }\n    }\n}\n{% endcodeblock %}\n따라치다보면 같은 클래스 명을 가진 라이브러리를 만날 수도 있습니다만…(안만날수도있고요) 무조건 io.netty.이하로 선택합니다.\n\n살펴보니 EventLoopGroup이라는 것을 만들어서 ServerBootStrap이라는 것에 집어넣습니다.채널에 클래스를 뭔가 하나 담고 밑에서 일할 핸들러를 하나 만들고 파이프라인이라는 것을 만들어서 마지막에 핸들러를 하나 담았습니다.그리고 8888 포트를 만들어서 sync메소드로 동기화같은 작업을 하나 봅니다.\n\n당연히 실행은 new EchoServer.echo()로 하겠지요.\n\n이번에는 파이프 라인에 들어갈 핸들러를 만들어 보겠습니다.\n\n{% codeblock %}\npublic class EchoServerHandler extends ChannelInboundHandlerAdapter {    \n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        String readMsg = ((ByteBuf)msg).toString(Charset.defaultCharset());\n        System.out.println(\"수신한 문자열 [\" + readMsg + \"]\");\n        ctx.write(msg);\n    }\n\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n        ctx.flush();\n    }\n    \n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        super.exceptionCaught(ctx, cause);\n        ctx.close();\n    }\n}\n{% endcodeblock %}\n\n이벤트 기반의 프레임워크라고 소개했듯이 핸들러를 통해 이벤트에 맞춰 어떻게 작업할 것인지 선택합니다.\n\n여기서는 ChannelInboundHandlerAdapter를 상속받아서 이벤트 콜백을 설정합니다.channelRead와 모두 완료됐을때 호출될 channelReadComplete를 오버라이드 해서 완료했을때의 이벤트를 설정합니다.\n\n그 다음 자바를 실행하고 telnet으로 접속해서 날려보면 자바 콘솔창에 확인이 가능합니다.\n\n<h2 id=\"에코-클라이언트-만들기\">에코 클라이언트 만들기</h2>\n\n{% codeblock %}\npublic class EchoClientHandler extends ChannelInboundHandlerAdapter {\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ByteBuf msgBuffer = Unpooled.buffer();\n        byte[] sendMsgByte = \"반가워요\".getBytes();\n        msgBuffer.writeBytes(sendMsgByte);\n        ctx.writeAndFlush(msgBuffer);\n    }\n    \n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        String readMsg = ((ByteBuf)msg).toString(Charset.defaultCharset());\n        System.out.println(\"수신한 문자열 [\"+readMsg + \"]\");\n        ctx.write(msg);\n    }    \n    \n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n        ctx.flush();\n    }\n}\n{% endcodeblock %}\n\n책에 나온 차이점이라면 처음에 채널이 연결되었을때 이벤트를 추가해준것 밖에 없습니다.실행해봅시다.\n\n<h2>간단한 용어 설명</h2>\n\n<h3 id=\"인바운드-아웃바운드\">인바운드, 아웃바운드</h3>\n\n인바운드란? 당사자 입장에서 들어오는 것\n\n아웃바운드란? 당사자 입장에서 나가는 것\n\n내가 친구에게 <code>안녕</code>이라는 메시지를 보냈다면, 친구입장에서는 <code>안녕</code>이라는 메시지가 인바운드 된 것이고 나에게는 <code>안녕</code>메시지가 아웃바운드 된 것이다.\n\n<h3 id=\"동기-비동기\">동기, 비동기</h3>\n\n이 것은 굳이 Netty가 아니더라도 수 많은 곳에서 사용합니다. 사전에 정의된 해설은 다음과 같습니다.\n\n동기란? 데이터 전송에 있어서 일정 클록 신호에 맞추어 데이터의 송수신을 하는 방법으로 통신을 시작할 때, 데이터의 최초에 통신 속도와 통신 방법을 식별하기 위한 동기 캐릭터(synchronous character)를 첨부하여 송신하는 방법\n\n비동기란? 통신을 하는 양쪽 장치가 데이터를 주고받을 때 일정한 속도를 유지하는 것이 아니라, 약정된 신호에 기준하여 동기를 맞추는 통신 방법\n\n<h3 id=\"블로킹-논블로킹\">블로킹, 논블로킹</h3>\n\n소켓통신에 주로 쓰이는 용어입니다. 물론 다른곳에도 쓰일수도 있지요.\n\n블로킹이란? 요청한 작업이 완료되거나 에러가 발생해서 끝날 때 까지 응답을 돌려주지 않는 방법\n논 블로킹이란? 작업 완료 여부와 상관없이 결과를 돌려주는 방법\n\n<h3 id=\"이벤트기반-프로그래밍\">이벤트기반 프로그래밍</h3>\n\n내가 설정한 이벤트가 발생하면 이벤트에 직접 등록한 루틴이 실행되는 방식입니다.즉, 이벤트 발생 -&gt; 이벤트를 받아서 처리할 것이 있는지 검색 -&gt; 실행 순이겠죠.\n\nNetty에서는 ChannelInboundHandlerAdapter로 여러 이벤트 기반 프로그래밍을 지원합니다.여기서 채널은 소켓 채널입니다.\n\n<h3 id=\"Future-java\">Future(java)</h3>\n간단하게 알아보면 어떠한 로직을 처리했을때 처리한 값을 받아 작업하는 방식입니다. 비동기에서 쓰이며 결과값을 얻을 때 까지 필요에 의해 블록처리가 될 수 있습니다.\n작업이 정상적으로 완료/취소 되었는지 확인을 위해 방법을 제공하며 성공적으로 수행시 <code>get</code> 취소했을경우 <code>cancel</code> 메소드로 수행됩니다.(인터페이스 기준)\n","tags":["Netty"],"categories":["Netty(복구중)"]}]